# Task 5 

## 学习目的

在Task 4中，你已经通过亲手实现反向传播，锻炼了作为AI工程师最硬核的“内功”。现在，是时候带着这份内功，去选择一门属于你的“主修兵器”了。本轮考核将是你专业方向的“定锚之战”，你将深入学习那些定义了现代深度学习的模块化设计思想与核心网络架构。

这次，你的任务不再是构建一个写死的两层网络，而是要学会如何设计和实现一个可扩展、可组合的深度神经网络，并最终亲手打造出计算机视觉领域的核心武器——**卷积神经网络 (CNN)**。

## 学习内容

本轮的学习将从“整体”走向“模块”，你将深入理解并实现构成现代神经网络的各个独立组件：

* **网络优化与正则化**: 批量归一化 (Batch Normalization), Dropout
* **模块化网络设计**: 将网络层（如全连接层、ReLU激活层）抽象为独立的、拥有`forward`和`backward`接口的模块。
* **卷积神经网络核心**: 卷积层 (Convolutional Layer) 的前向与反向传播，池化层 (Pooling Layer) 的前向与反向传播。
* **现代框架实践**: 在手动实现所有核心组件后，使用高层框架（如PyTorch）快速搭建一个高性能的CNN模型。

## 学习要求

本轮考核的难度相较于Task 4有显著提升，主要体现在以下两个方面：

1. **抽象思维的转变**: 你需要从为整个网络编写一个统一的`loss`和`gradient`函数，转变为为**每一个独立的层**编写`forward`和`backward`函数。这种模块化的设计思想是所有现代深度学习框架的基石。
2. **数学与实现的挑战**: 卷积层的反向传播在数学上和实现上都比全连接层更为复杂。你需要花费大量时间阅读课程笔记，理解梯度是如何在卷积和池化操作中流动的。

请务必将课程笔记（Notes）作为你最主要的学习材料。只有在真正理解了每一层的计算原理后，你才有可能成功地完成代码实现。

## 作业

### 作业1

**核心任务：完成 [CS231n Assignment 2](https://cs231n.github.io/assignments2025/assignment2/)**

本次作业分为三个循序渐进的部分，将引导你完成一次从底层构建到高层应用的完整体验：

#### 第一部分：模块化全连接网络 (Fully-Connected Nets)

在这一部分，你将告别Task 4中的“一体化”网络，开始构建一个可以自由堆叠层数的深度神经网络。你需要：

* 为**每一个基础层**（Affine, ReLU, Softmax Loss等）实现独立的`forward`和`backward`函数。
* 在此基础上，实现**批量归一化 (Batch Normalization)**和**Dropout**层的前向与反向传播。
* 将这些独立的层组合起来，构建一个可以任意指定层数和隐藏单元数量的全连接网络。
* 实现一个通用的`Solver`类来训练你的模型，并用它来寻找最佳的网络配置。

#### 第二部分：卷积神经网络 (Convolutional Nets)

这是本次作业的核心与亮点。你将亲手揭开CNN的神秘面纱，实现其最重要的两个组成部分：

* **卷积层 (Convolutional Layer)**: 实现其`forward`和`backward`传播。这是整个作业中最具挑战性的部分。
* **最大池化层 (Max-Pooling Layer)**: 实现其`forward`和`backward`传播。
* 将这些新的卷积组件与你之前实现的全连接层组合起来，构建一个真正的卷积神经网络。

#### 第三部分：现代框架实践 (PyTorch)

在经历了手动实现所有核心组件的“磨难”之后，你将体验到现代深度学习框架的强大与便捷。在这一部分，你需要：

* 使用 **PyTorch** 重新搭建一个更为复杂的卷积神经网络。
* 利用框架提供的自动求导、GPU加速等功能，在CIFAR-10数据集上训练你的模型，并冲击尽可能高的准确率。

> 完成这次作业后，你将对一个问题有醍醐灌顶般的理解：“我们为什么需要PyTorch这样的框架？” 因为你已经亲身走过了最艰难的底层实现之路。这种“先苦后甜”的体验，将让你对深度学习的理解超越绝大多数仅仅停留在调包层面的人。

---

### 作业2 根据MNIST数据集实现一个简单的识别数字的demo（选做）

**核心任务：实现并部署一个基于 TensorFlow\.js 的 MNIST 手写数字识别 Web应用。**

该项目的最终成果可以在[这里](https://shaddocknh3.github.io/tfjs-mnist-digit-recognizer/)体验。

本次作业的目标是让你亲历一个AI应用从训练到部署的全过程。你将以 [该项目](https://github.com/ShaddockNH3/tfjs-mnist-digit-recognizer) 为基础框架，但核心的识别模型需要由你自己亲手训练和替换。

你的任务是基于MNIST数据集训练一个识别数字的demo，应该fork[该项目](https://github.com/ShaddockNH3/tfjs-mnist-digit-recognizer)，然后替换原仓库model文件夹下的两个训练文件。

你不需要实现前端。

#### 第一部分：训练你的专属识别模型 (Train Your Own Recognition Model)

原项目（指的是旧版实现，本人已替换为新版实现）中的模型存在版本兼容性或识别效果不佳的问题。现在，你的首要任务是使用CNN亲自训练一个全新的、更强大的识别模型。

* **环境与工具:** 你需要在 Python 环境下，使用 Keras 框架来完成此任务。
* **模型构建:** 在经典的 MNIST 数据集上，从零开始构建并训练一个卷积神经网络 (CNN)。你需要自行设计网络结构、选择优化器和损失函数，并进行超参数调整，以达到尽可能高的识别准确率。
* **产出:** 训练完成后，你将得到一个 Keras 模型文件（通常是 `.h5` 格式），这是我们后续工作的基础。

#### 第二部分：模型转换与前端整合 (Model Conversion & Frontend Integration)

浏览器里的 JavaScript 不认识 Python 的模型文件，所以我们需要一座桥梁，将你在Python世界里创造的“大脑”移植到Web世界中。

* **模型转换:** 你需要学习并使用 `tensorflowjs_converter` 这个官方工具。它的作用是将上一步得到的 `.h5` 模型文件，转换成 TensorFlow\.js 能够加载和理解的格式，即一个 `model.json` (模型结构) 和一个 `.bin` 权重文件。
* **核心替换:** 将你亲手生成的新模型文件（`model.json` 和 `.bin` 文件），替换掉基础项目仓库中 `/model/` 文件夹下的所有旧文件。这是让你的AI应用拥有“新灵魂”的关键一步。

#### 第三部分：部署、验证与优化 (Deploy, Verify & Optimize)

测试可以参考[该项目](https://github.com/ShaddockNH3/tfjs-mnist-digit-recognizer)的部署，一般而言，报错了是版本不匹配，而不是前端出了问题。

* **在线部署:** 将你修改后的整个项目，通过 **GitHub Pages** 功能发布，生成一个任何人都可以通过浏览器访问的公开网页链接。
* **多端验证:** 在PC和\*\*移动端（手机）\*\*上打开你的应用，在画板上写下数字进行测试。检验识别功能是否正常工作，特别是解决原项目在手机上无法正确识别的问题。
* **调试与修复:** 仔细观察浏览器开发者工具(F12)中的控制台。如果在加载模型或进行预测时出现任何报错信息，你需要像侦探一样去分析问题根源，并尝试修复它。

在完成最终的模型后，你应该替换`index.html`的第6行为自己的github用户名

#### 参考资料

* [参考实现: 使用Keras.js的旧版思路](https://github.com/starkwang/keras-js-demo)
* [参考教程: 从训练到部署的详细步骤](https://www.cnblogs.com/chinasoft/p/17084356.html)
* [TensorFlow.js 官方文档](https://www.tensorflow.org/js/guide?hl=zh-cn)

#### 提示

- 该项目可以全程跑在colab上，你可以参考答案[train.ipynb](https://github.com/ShaddockNH3/tfjs-mnist-digit-recognizer/blob/train/training/train.ipynb)，但不要抄袭代码

---

## 作业要求

1. **严禁抄袭**。本次作业的代码复杂度很高，但独立思考和调试的过程是你收获成长的唯一途径。
2. **善用工具**。遇到问题时，首先尝试通过搜索引擎、官方文档和AI助手解决。如果仍然无法解决，欢迎在群里进行有深度的提问。
3. **拥抱AI，但保持思考**。不限制使用ChatGPT等大语言模型工具，但你必须确保能完全理解模型生成的每一行代码。
4. **规范化提交**。所有作业均需通过Git提交到你个人的GitHub仓库中。

## 作业提交方式

1. 在你的个人GitHub仓库中为本次作业创建一个新的文件夹 (例如 `task5-cs231n-a2`)。
2. 将你完成的所有代码（`.py`和`.ipynb`文件）上传到该文件夹。
3. 通过Pull Request的方式，在课程仓库的 `solutions.md` 文件中更新你的仓库地址。
